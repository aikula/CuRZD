{
  "paragraphs": [
    {
      "text": "%md\n# Основы работы с базами данных\n\nЯдром любой базы данных является модель данных. С помощью модели данных могут быть представлены объекты предметной области и взаимосвязи между ними.\nМодель данных - это совокупность структур данных и операций их обработки. Выделяют большое количество моделей данных:\nЛогические модели:\n-\tИерархическая модель\n-\tСетевая модель\n-\tРеляционная модель\n-\tМодель «сущность — связь» (ER)\n-\tМодель «сущность — атрибут — значение» (EAV)\n-\tОбъектно-ориентированная модель (из ООП)\n-\tДокументная модель\n-\tЗвёздная модель и модель снежинки\n\nФизические модели:\n-\tПлоская модель\n-\tТабличная модель\n-\tИнвертированная модель\n\nПрочие модели:\n-\tАссоциативная модель\n-\tКорреляционная модель\n-\tСемантическая модель\n-\tМодель XML\n-\tMultiValue\n-\tСемантическая паутина и именованные графы\n-\tСклад троек\n\nРассмотрим четыре основных типа моделей данных: иерархическую, сетевую, реляционную и объектно-ориентированную.\n\nИерархическая модель представляет собой совокупность элементов, расположенных в порядке их подчинения от общего к частному и образующих перевернутое по структуре дерево (граф).\n\nК основным понятиям иерархической структуры относятся уровень, узел и связь. Узел - это совокупность атрибутов данных, описывающих некоторый объект. На схеме иерархического дерева узлы представляются вершинами графа. Каждый узел на более низком уровне связан только с одним узлом, находящимся на более высоком уровне. Иерархическое дерево имеет только одну вершину, не подчиненную никакой другой вершине и находящуюся на самом верхнем - первом уровне. Зависимые (подчиненные) узлы находятся на втором, третьем и т. д. уровнях. Количество деревьев в базе данных определяется числом корневых записей. К каждой записи базы данных существует только один иерархический путь от корневой записи.\nВ сетевой структуре при тех же основных понятиях (уровень, узел, связь) каждый элемент может быть связан с любым другим элементом.\n\n![Сетевая структура БД](http://edu.tltsu.ru/er/er_files/page27984/img/image050.jpg)\n\nРеляционная модель данных объекты и связи между ними представляет в виде таблиц, при этом связи тоже рассматриваются как объекты. Все строки, составляющие таблицу в реляционной базе данных, должны иметь первичный ключ. Все современные средства СУБД поддерживают реляционную модель данных.\n\n![Реляционная модель базы данных](https://cdn.otus.ru/media/public/63/5d/11-20219-635d9f.jpg)\n\nЭта модель характеризуется простотой структуры данных, удобным для пользователя табличным представлением и возможностью использования формального аппарата алгебры отношений и реляционного исчисления для обработки данных.\nКаждая реляционная таблица представляет собой двумерный массив и обладает следующими свойствами:\n1.\tКаждый элемент таблицы соответствует одному элементу данных.\n2.\tВсе столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину.\n3.\tКаждый столбец имеет уникальное имя.\n4.\tОдинаковые строки в таблице отсутствуют.\n5.\tПорядок следования строк и столбцов может быть произвольным.\n\nОбъектная и объектно-ориентированная – данные в таких базах представляют из себя объекты с определенными наборами свойств, методов и поведения. Отношения данных объектов строятся на основе обобщения свойств, методов и поведения различных объектов по отношению друг к другу.\n\nНа практике же мы будем сталкиваться скорее с другой классификацией баз данных.\n\n## Плоские файлы\n\nСамый простой вариант хранения структурированных данных - это плоские файлы. Свое название они получили потому, что имеют минимальную структуру. Если сравнить их со зданиями, то стены этого здания стоят на земле, а не на фундаменте. Плоский файл содержит в себе набор записей данных, которые записываются в определенном формате друг за другом. В файле находятся только данные и ничего кроме них, т.е. список. Файл не содержит метаданных (сведений о структуре хранимой информации). Вот пример такого файла: первая строка - названия колонок, вторая и далее - данные. Между собой значения колонок разделяются запятыми (или иным выбранным символом). Нужно самостоятельно разбираться, какой тип имеет каждая колонка.\nТакая форма хранения отлично подходит для простых списков, например e-mail-адреса для рассылки или телефон + ФИО для обзвона. Но для более сложной информации не годится. Например, неудобно хранить в плоском списке информацию, если одной фамилии соответствует несколько телефонов. Их придется перечислять через запятую или делать на каждую фамилию столько строк, сколько у человека телефонных номеров.\n\n## Реляционная модель\n\nМы уже говорили про нее.\n\nДля работы с реляционными базами данных был разработан язык запросов SQL. Изначально он планировался как доступный после небольшой подготовки неспециалисту, близкий к живому английскому язык запросов. Например: «Выбери всех сотрудников, у которых зарплата больше 100 000». Однако со временем этот язык дорабатывался и усложнялся, но основные команды остались легкими и понятными. Реляционная модель данных строго формализует структуру хранения данных. Если требуется хранить слабоструктурированные данные или разноплановые данные в каждой строке таблицы, то реляционная модель окажется излишне строгой и заставит проектировать гораздо больше таблиц. Реляционные базы лучше всего подходят для однотипных, формализованных данных. Например, каталоги и справочники, стандартизованные документы, которые редко меняются (как в РЖД). Эти базы позволяют быстро получить ответ на вопрос «В каком месяце были самые большие продажи?» или «Какой товар самый популярный в этом квартале и какие клиенты покупали его?»\n\nНеудобно хранить в реляционной базе энциклопедию фильмов: человек может играть несколько ролей в одном фильме, одного героя могут играть несколько актеров (в детстве и зрелом возрасте). Или хранить разноплановые документы, приходящие из разных систем и часто меняющие свою структуру.\n\n## Безмодельный (NoSQL) подход\n\nЧтобы избавиться от недостатков, вызванных строгостью реляционных баз, появился NoSQL-способ структуризации данных. Следует отметить, что NoSQL расшифровывается как Not Only SQL, т.е. «Не только SQL». Он не отрицает запросы, но эти запросы не похожи на стандартный SQL. Базы данных NoSQL используют неструктуризированный подход, они предлагают много более эффективных способов хранения и обработки данных. Но каждый способ применим только в определенных ситуациях. Например, документоориентированные базы хранят информацию в виде иерархических структур данных. При этом они могут хранить объекты с произвольным набором атрибутов, отличающиеся друг от друга. То, что в реляционной БД необходимо разделить на множество взаимосвязанных таблиц, в NoSQL может храниться в виде одного объекта.\n\nНиже рассмотрены виды NoSQL баз. Каждая из них оптимизирована для решения определенного круга задач.\n\n### Базы данных ключ-значение\n\nЭтот тип БД работает только с данными, похожими на словарь, ключ (слово) и значение (словарная статья по этому слову). В такой базе ключем и значением может быть все что угодно.\n\nВ такой базе нет структур и связей. Подключившись к серверу, приложение может задать ключ и его значение, а потом получить эти данные. Такие СУБД используются для быстрого сохранения базовых данных, к которым впоследствии нужен быстрый доступ. Такие базы очень быстры и легко масштабируемы. Отлично подходят для хранения данных пользовательской сессии на сайте, кеша, счётчиков посещений или просмотров и т.д.\n\nНедостаток: нет запросов и связей между ячейками, это именно хранилище данных. Такая база не ответит на вопрос «Кто из посетителей сайта смотрел страницу с нашими новостями?»\n\n### Документоориентированные базы данных\n\nЭтот тип баз данных ориентирован на хранение документов, имеющих различную структуру в том виде «как есть». Такие NoSQL СУБД допускают большую вложенность и сложность данных (например, документ, вложенный в документ, вложенный в документ). Можно создать сколь угодно сложную структуру данных как документ и сохранить в базе. Эти СУБД имеют ряд своих особенностей. Они удобны для поиска в документах, но не для построения связей между ними. Такая база отлично подойдет под хранение данных о фильмах, из примера, приведенного выше, или историй болезни. В базе хранятся коллекции, внутри коллекций - документы. А в документах в полях (field) хранится информация. Поле может быть отдельным документом, так что внутри документов могут быть вложенные документы.\n\n## Базы данных на основе графов\n\nБазы данных на основе графов хранят данные в древовидных структурах с узлами и связями, соединяющими их. Некоторые операции удобнее (нагляднее) выполнять именно с таким представлением данных. Например, сведения о географических объектах. Загородный санаторий расположен вне населенных пунктов, но находится вблизи от трех городов, двух шоссе. Кроме того, вокруг него расположены интересные места, с которыми он тоже связан. Такая база не подойдет для хранения статистических табличных данных, т.е. время выполнения запросов по таким данным в реляционных базах гораздо меньше.\n\n# Виды баз данных и их особенности реализации\n\nСистема хранения данных РЖД построена на экосистеме с открытым исходным кодом Hadoop. Hadoop — это фреймворк, состоящий из набора утилит для разработки и выполнения программ распределенных вычислений.\n\nИдея родилась в 2004 году: Google публикует работу, в которой рассказывает о технологии BigTable и MapReduce (на которой сейчас держатся NoSQL-базы данных). В 2006 году Yahoo выпускает открытую реализацию и дает ей имя Hadoop. В 2010 году была создана экосистема технологий, делающая Hadoop применимой и популярной.\n\n## Зачем нужен Hadoop?\n\nОбъем данных за последние несколько лет растет с большой скоростью и обещает продолжать в том же духе. Именно это и послужило предпосылкой для написания Google вышеупомянутой работы: стандартные базы данных больше не могли поддерживать работоспособность при таком темпе.\n\nОбработка, хранение и все вытекающие действия с такими объемами данных и есть Big Data. Hadoop — технология работы с BigData.\n\n## Кем используется?\n\nУ Hadoop хороший послужной список: eBay, Amazon, IBM, Facebook и т.д. Нет единой схемы для работы с данными абсолютно любой компании: работа всех сервисов, даже не слишком больших, очень специфична. Поэтому на основной функционал накладываются дополнительные фичи, разработанные специально для конкретных компаний.\n\n## Некоторые инструмены экосистемы:\n-\t**HBase** — NoSQL СУБД, эффективно поддерживающая случайное чтение и запись;\n-\t**Pig** — язык обработки данных и среда выполнения;\n-\t**SPARK** — набор инструментов для реализации распределенных вычислений;\n-\t**Hive** — хранилище данных с интерфейсом SQL;\n-\t**HDFS** (Hadoop Distributed File System) – файловая система, предназначенная для хранения файлов больших размеров;\n-\t**HBase** – нереляционная распределённая база данных;\n-\t**Hadoop MapReduce** – платформа программирования и выполнения распределённых MapReduce-вычислений с использованием большого количества компьютеров (узлов, nodes), образующих кластер.\n\nИ другие, система постоянно развивается. \n\nОсновные – HDFS и MapReduce. Первое — файловая система, второе — фреймворк обработки данных.",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Основы работы с базами данных</h1>\n<p>Ядром любой базы данных является модель данных. С помощью модели данных могут быть представлены объекты предметной области и взаимосвязи между ними.<br />\nМодель данных - это совокупность структур данных и операций их обработки. Выделяют большое количество моделей данных:<br />\nЛогические модели:</p>\n<ul>\n<li>Иерархическая модель</li>\n<li>Сетевая модель</li>\n<li>Реляционная модель</li>\n<li>Модель «сущность — связь» (ER)</li>\n<li>Модель «сущность — атрибут — значение» (EAV)</li>\n<li>Объектно-ориентированная модель (из ООП)</li>\n<li>Документная модель</li>\n<li>Звёздная модель и модель снежинки</li>\n</ul>\n<p>Физические модели:</p>\n<ul>\n<li>Плоская модель</li>\n<li>Табличная модель</li>\n<li>Инвертированная модель</li>\n</ul>\n<p>Прочие модели:</p>\n<ul>\n<li>Ассоциативная модель</li>\n<li>Корреляционная модель</li>\n<li>Семантическая модель</li>\n<li>Модель XML</li>\n<li>MultiValue</li>\n<li>Семантическая паутина и именованные графы</li>\n<li>Склад троек</li>\n</ul>\n<p>Рассмотрим четыре основных типа моделей данных: иерархическую, сетевую, реляционную и объектно-ориентированную.</p>\n<p>Иерархическая модель представляет собой совокупность элементов, расположенных в порядке их подчинения от общего к частному и образующих перевернутое по структуре дерево (граф).</p>\n<p>К основным понятиям иерархической структуры относятся уровень, узел и связь. Узел - это совокупность атрибутов данных, описывающих некоторый объект. На схеме иерархического дерева узлы представляются вершинами графа. Каждый узел на более низком уровне связан только с одним узлом, находящимся на более высоком уровне. Иерархическое дерево имеет только одну вершину, не подчиненную никакой другой вершине и находящуюся на самом верхнем - первом уровне. Зависимые (подчиненные) узлы находятся на втором, третьем и т. д. уровнях. Количество деревьев в базе данных определяется числом корневых записей. К каждой записи базы данных существует только один иерархический путь от корневой записи.<br />\nВ сетевой структуре при тех же основных понятиях (уровень, узел, связь) каждый элемент может быть связан с любым другим элементом.</p>\n<p><img src=\"http://edu.tltsu.ru/er/er_files/page27984/img/image050.jpg\" alt=\"Сетевая структура БД\" /></p>\n<p>Реляционная модель данных объекты и связи между ними представляет в виде таблиц, при этом связи тоже рассматриваются как объекты. Все строки, составляющие таблицу в реляционной базе данных, должны иметь первичный ключ. Все современные средства СУБД поддерживают реляционную модель данных.</p>\n<p><img src=\"https://cdn.otus.ru/media/public/63/5d/11-20219-635d9f.jpg\" alt=\"Реляционная модель базы данных\" /></p>\n<p>Эта модель характеризуется простотой структуры данных, удобным для пользователя табличным представлением и возможностью использования формального аппарата алгебры отношений и реляционного исчисления для обработки данных.<br />\nКаждая реляционная таблица представляет собой двумерный массив и обладает следующими свойствами:</p>\n<ol>\n<li>Каждый элемент таблицы соответствует одному элементу данных.</li>\n<li>Все столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину.</li>\n<li>Каждый столбец имеет уникальное имя.</li>\n<li>Одинаковые строки в таблице отсутствуют.</li>\n<li>Порядок следования строк и столбцов может быть произвольным.</li>\n</ol>\n<p>Объектная и объектно-ориентированная – данные в таких базах представляют из себя объекты с определенными наборами свойств, методов и поведения. Отношения данных объектов строятся на основе обобщения свойств, методов и поведения различных объектов по отношению друг к другу.</p>\n<p>На практике же мы будем сталкиваться скорее с другой классификацией баз данных.</p>\n<h2>Плоские файлы</h2>\n<p>Самый простой вариант хранения структурированных данных - это плоские файлы. Свое название они получили потому, что имеют минимальную структуру. Если сравнить их со зданиями, то стены этого здания стоят на земле, а не на фундаменте. Плоский файл содержит в себе набор записей данных, которые записываются в определенном формате друг за другом. В файле находятся только данные и ничего кроме них, т.е. список. Файл не содержит метаданных (сведений о структуре хранимой информации). Вот пример такого файла: первая строка - названия колонок, вторая и далее - данные. Между собой значения колонок разделяются запятыми (или иным выбранным символом). Нужно самостоятельно разбираться, какой тип имеет каждая колонка.<br />\nТакая форма хранения отлично подходит для простых списков, например e-mail-адреса для рассылки или телефон + ФИО для обзвона. Но для более сложной информации не годится. Например, неудобно хранить в плоском списке информацию, если одной фамилии соответствует несколько телефонов. Их придется перечислять через запятую или делать на каждую фамилию столько строк, сколько у человека телефонных номеров.</p>\n<h2>Реляционная модель</h2>\n<p>Мы уже говорили про нее.</p>\n<p>Для работы с реляционными базами данных был разработан язык запросов SQL. Изначально он планировался как доступный после небольшой подготовки неспециалисту, близкий к живому английскому язык запросов. Например: «Выбери всех сотрудников, у которых зарплата больше 100 000». Однако со временем этот язык дорабатывался и усложнялся, но основные команды остались легкими и понятными. Реляционная модель данных строго формализует структуру хранения данных. Если требуется хранить слабоструктурированные данные или разноплановые данные в каждой строке таблицы, то реляционная модель окажется излишне строгой и заставит проектировать гораздо больше таблиц. Реляционные базы лучше всего подходят для однотипных, формализованных данных. Например, каталоги и справочники, стандартизованные документы, которые редко меняются (как в РЖД). Эти базы позволяют быстро получить ответ на вопрос «В каком месяце были самые большие продажи?» или «Какой товар самый популярный в этом квартале и какие клиенты покупали его?»</p>\n<p>Неудобно хранить в реляционной базе энциклопедию фильмов: человек может играть несколько ролей в одном фильме, одного героя могут играть несколько актеров (в детстве и зрелом возрасте). Или хранить разноплановые документы, приходящие из разных систем и часто меняющие свою структуру.</p>\n<h2>Безмодельный (NoSQL) подход</h2>\n<p>Чтобы избавиться от недостатков, вызванных строгостью реляционных баз, появился NoSQL-способ структуризации данных. Следует отметить, что NoSQL расшифровывается как Not Only SQL, т.е. «Не только SQL». Он не отрицает запросы, но эти запросы не похожи на стандартный SQL. Базы данных NoSQL используют неструктуризированный подход, они предлагают много более эффективных способов хранения и обработки данных. Но каждый способ применим только в определенных ситуациях. Например, документоориентированные базы хранят информацию в виде иерархических структур данных. При этом они могут хранить объекты с произвольным набором атрибутов, отличающиеся друг от друга. То, что в реляционной БД необходимо разделить на множество взаимосвязанных таблиц, в NoSQL может храниться в виде одного объекта.</p>\n<p>Ниже рассмотрены виды NoSQL баз. Каждая из них оптимизирована для решения определенного круга задач.</p>\n<h3>Базы данных ключ-значение</h3>\n<p>Этот тип БД работает только с данными, похожими на словарь, ключ (слово) и значение (словарная статья по этому слову). В такой базе ключем и значением может быть все что угодно.</p>\n<p>В такой базе нет структур и связей. Подключившись к серверу, приложение может задать ключ и его значение, а потом получить эти данные. Такие СУБД используются для быстрого сохранения базовых данных, к которым впоследствии нужен быстрый доступ. Такие базы очень быстры и легко масштабируемы. Отлично подходят для хранения данных пользовательской сессии на сайте, кеша, счётчиков посещений или просмотров и т.д.</p>\n<p>Недостаток: нет запросов и связей между ячейками, это именно хранилище данных. Такая база не ответит на вопрос «Кто из посетителей сайта смотрел страницу с нашими новостями?»</p>\n<h3>Документоориентированные базы данных</h3>\n<p>Этот тип баз данных ориентирован на хранение документов, имеющих различную структуру в том виде «как есть». Такие NoSQL СУБД допускают большую вложенность и сложность данных (например, документ, вложенный в документ, вложенный в документ). Можно создать сколь угодно сложную структуру данных как документ и сохранить в базе. Эти СУБД имеют ряд своих особенностей. Они удобны для поиска в документах, но не для построения связей между ними. Такая база отлично подойдет под хранение данных о фильмах, из примера, приведенного выше, или историй болезни. В базе хранятся коллекции, внутри коллекций - документы. А в документах в полях (field) хранится информация. Поле может быть отдельным документом, так что внутри документов могут быть вложенные документы.</p>\n<h2>Базы данных на основе графов</h2>\n<p>Базы данных на основе графов хранят данные в древовидных структурах с узлами и связями, соединяющими их. Некоторые операции удобнее (нагляднее) выполнять именно с таким представлением данных. Например, сведения о географических объектах. Загородный санаторий расположен вне населенных пунктов, но находится вблизи от трех городов, двух шоссе. Кроме того, вокруг него расположены интересные места, с которыми он тоже связан. Такая база не подойдет для хранения статистических табличных данных, т.е. время выполнения запросов по таким данным в реляционных базах гораздо меньше.</p>\n<h1>Виды баз данных и их особенности реализации</h1>\n<p>Система хранения данных РЖД построена на экосистеме с открытым исходным кодом Hadoop. Hadoop — это фреймворк, состоящий из набора утилит для разработки и выполнения программ распределенных вычислений.</p>\n<p>Идея родилась в 2004 году: Google публикует работу, в которой рассказывает о технологии BigTable и MapReduce (на которой сейчас держатся NoSQL-базы данных). В 2006 году Yahoo выпускает открытую реализацию и дает ей имя Hadoop. В 2010 году была создана экосистема технологий, делающая Hadoop применимой и популярной.</p>\n<h2>Зачем нужен Hadoop?</h2>\n<p>Объем данных за последние несколько лет растет с большой скоростью и обещает продолжать в том же духе. Именно это и послужило предпосылкой для написания Google вышеупомянутой работы: стандартные базы данных больше не могли поддерживать работоспособность при таком темпе.</p>\n<p>Обработка, хранение и все вытекающие действия с такими объемами данных и есть Big Data. Hadoop — технология работы с BigData.</p>\n<h2>Кем используется?</h2>\n<p>У Hadoop хороший послужной список: eBay, Amazon, IBM, Facebook и т.д. Нет единой схемы для работы с данными абсолютно любой компании: работа всех сервисов, даже не слишком больших, очень специфична. Поэтому на основной функционал накладываются дополнительные фичи, разработанные специально для конкретных компаний.</p>\n<h2>Некоторые инструмены экосистемы:</h2>\n<ul>\n<li><strong>HBase</strong> — NoSQL СУБД, эффективно поддерживающая случайное чтение и запись;</li>\n<li><strong>Pig</strong> — язык обработки данных и среда выполнения;</li>\n<li><strong>SPARK</strong> — набор инструментов для реализации распределенных вычислений;</li>\n<li><strong>Hive</strong> — хранилище данных с интерфейсом SQL;</li>\n<li><strong>HDFS</strong> (Hadoop Distributed File System) – файловая система, предназначенная для хранения файлов больших размеров;</li>\n<li><strong>HBase</strong> – нереляционная распределённая база данных;</li>\n<li><strong>Hadoop MapReduce</strong> – платформа программирования и выполнения распределённых MapReduce-вычислений с использованием большого количества компьютеров (узлов, nodes), образующих кластер.</li>\n</ul>\n<p>И другие, система постоянно развивается.</p>\n<p>Основные – HDFS и MapReduce. Первое — файловая система, второе — фреймворк обработки данных.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604125021543_1169759646",
      "id": "paragraph_1604125021543_1169759646",
      "dateCreated": "2020-10-31T07:17:01+0100",
      "dateStarted": "2020-11-01T19:37:21+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "focus": true,
      "$$hashKey": "object:10103"
    },
    {
      "text": "%md\n# Основы работы с базами данных\n\nПрезентация о моделях данных и видах баз данных.\n\n## Подклюбчение к базам данных\n\nВ \"боевых\" условиях вы будете работать с драйвером дял подключения к базе данных Phoenix. Процедура подключения и организация запросов выглядит следующим образом:\n\n```python\ndb=phoenixdb.connect('http://localhost:8765', autocommit=True)\nwith db.cursor() as cursor:\n    cursor.execute(\"DROP TABLE IF EXIST test\")\n    cursor.execute(\"CREATE TABLE test (id INTEGER PRIMARY KEY, text VARCHAR)\")\n    cursor.executemany(\"UPSERT INTO test VALUES (?,?)\", [[i, 'text {}'.format(i)] for range(10)])\n```\n\nПервая строчка кода - это подключение к базе данных. Далее удаляем таблицу, если существует, создаем таблицу и добавляем 10 строчек данных. В этих запросах используется язык SQL. На учебном кластере мы будем работать с несколько другой базой данных и схемой подключения, но язык запросов останется совершенно таким же. \n\n`with` - оператор контекста. Позволяет не заботиться о том, котрыли и не забыли ли мы закрыть подключение к базе.\n\nМы будем работать с базой данных MySQL. Подключение к ней будет выглядеть вот так.\n\n```python\nimport sqlalchemy\n\nengine = sqlalchemy.create_engine(\n                \"mysql+pymysql://root:KGM9oZb3Fb9gKME@127.0.0.1:3306/rzd\", encoding='utf8', convert_unicode=True\n            )\n\nwith engine.connect() as session:\n    sql=\"SHOW TABLES\"\n    r=session.execute(sql)\n    print(r.fetchall())\n    \n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Основы работы с базами данных</h1>\n<p>Презентация о моделях данных и видах баз данных.</p>\n<h2>Подклюбчение к базам данных</h2>\n<p>В &ldquo;боевых&rdquo; условиях вы будете работать с драйвером дял подключения к базе данных Phoenix. Процедура подключения и организация запросов выглядит следующим образом:</p>\n<pre><code class=\"language-python\">db=phoenixdb.connect('http://localhost:8765', autocommit=True)\nwith db.cursor() as cursor:\n    cursor.execute(&quot;DROP TABLE IF EXIST test&quot;)\n    cursor.execute(&quot;CREATE TABLE test (id INTEGER PRIMARY KEY, text VARCHAR)&quot;)\n    cursor.executemany(&quot;UPSERT INTO test VALUES (?,?)&quot;, [[i, 'text {}'.format(i)] for range(10)])\n</code></pre>\n<p>Первая строчка кода - это подключение к базе данных. Далее удаляем таблицу, если существует, создаем таблицу и добавляем 10 строчек данных. В этих запросах используется язык SQL. На учебном кластере мы будем работать с несколько другой базой данных и схемой подключения, но язык запросов останется совершенно таким же.</p>\n<p><code>with</code> - оператор контекста. Позволяет не заботиться о том, котрыли и не забыли ли мы закрыть подключение к базе.</p>\n<p>Мы будем работать с базой данных MySQL. Подключение к ней будет выглядеть вот так.</p>\n<pre><code class=\"language-python\">import sqlalchemy\n\nengine = sqlalchemy.create_engine(\n                &quot;mysql+pymysql://root:KGM9oZb3Fb9gKME@127.0.0.1:3306/rzd&quot;, encoding='utf8', convert_unicode=True\n            )\n\nwith engine.connect() as session:\n    sql=&quot;SHOW TABLES&quot;\n    r=session.execute(sql)\n    print(r.fetchall())\n    \n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126588450_802273368",
      "id": "paragraph_1604126588450_802273368",
      "dateCreated": "2020-10-31T07:43:08+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10104"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:40:07+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126620356_1656463171",
      "id": "paragraph_1604126620356_1656463171",
      "dateCreated": "2020-10-31T07:43:40+0100",
      "dateStarted": "2020-11-01T19:40:01+0100",
      "dateFinished": "2020-11-01T19:40:01+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10105"
    },
    {
      "text": "%md\nОсновные действия, которые происходят в базах данных, – это:\n-\tДобавление (`Create`)\n-\tЧтение (`Read`)\n-\tИзменение (`Update`)\n-\tУдаление (`Delete`)\nВсе эти действия описываются аббревиатурой CRUD. \n\nТак как в нашем случае данные будут генерироваться другими подсистемами, то мы в основном сосредоточимся на навыках извлечения (SELECT) данных. \n\nВ первую очередь, нам полезны будут такие команды как показать все таблицы и показать структуру конкретной таблицы. \n\n```python\nwith engine.connect() as session: # покажет список всех таблиц базы данных, к которой поключились\n    sql=\"SHOW TABLES;\"\n    r=session.execute(sql)\n    print(r.fetchall())\n\nwith engine.connect() as session: # покажет структуру все столбцов таблицы\n    sql=\"SHOW COLUMNS FROM sng_all_station;\" \n    r=session.execute(sql)\n    print(r.fetchall())\n\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Основные действия, которые происходят в базах данных, – это:</p>\n<ul>\n<li>Добавление (<code>Create</code>)</li>\n<li>Чтение (<code>Read</code>)</li>\n<li>Изменение (<code>Update</code>)</li>\n<li>Удаление (<code>Delete</code>)<br />\nВсе эти действия описываются аббревиатурой CRUD.</li>\n</ul>\n<p>Так как в нашем случае данные будут генерироваться другими подсистемами, то мы в основном сосредоточимся на навыках извлечения (SELECT) данных.</p>\n<p>В первую очередь, нам полезны будут такие команды как показать все таблицы и показать структуру конкретной таблицы.</p>\n<pre><code class=\"language-python\">with engine.connect() as session: # покажет список всех таблиц базы данных, к которой поключились\n    sql=&quot;SHOW TABLES;&quot;\n    r=session.execute(sql)\n    print(r.fetchall())\n\nwith engine.connect() as session: # покажет структуру все столбцов таблицы\n    sql=&quot;SHOW COLUMNS FROM sng_all_station;&quot; \n    r=session.execute(sql)\n    print(r.fetchall())\n\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126634165_161262092",
      "id": "paragraph_1604126634165_161262092",
      "dateCreated": "2020-10-31T07:43:54+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10106"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-10-31T08:20:56+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python",
        "editorHide": false,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126636807_767570931",
      "id": "paragraph_1604126636807_767570931",
      "dateCreated": "2020-10-31T07:43:56+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10107"
    },
    {
      "text": "%md\nТеперь вопробуем получить данные из таблицы. Команда выбора данных всегда начинается со слова “SELECT”, потом перечень полей, которые мы хотим вернуть, или значок `*`, если хотим получить все поля из таблицы, а потом имя самой таблицы.\n\n```python\nwith engine.connect() as session:\n    sql=\"SELECT * FROM sng_all_station;\"\n    r=session.execute(sql)\n    result=r.fetchall()\nprint(type(result)) # ><class 'list'>\nprint(len(result)) # 8475 количество строк\nprint(result[:5])\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Теперь вопробуем получить данные из таблицы. Команда выбора данных всегда начинается со слова “SELECT”, потом перечень полей, которые мы хотим вернуть, или значок <code>*</code>, если хотим получить все поля из таблицы, а потом имя самой таблицы.</p>\n<pre><code class=\"language-python\">with engine.connect() as session:\n    sql=&quot;SELECT * FROM sng_all_station;&quot;\n    r=session.execute(sql)\n    result=r.fetchall()\nprint(type(result)) # &gt;&lt;class 'list'&gt;\nprint(len(result)) # 8475 количество строк\nprint(result[:5])\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126827532_1239732384",
      "id": "paragraph_1604126827532_1239732384",
      "dateCreated": "2020-10-31T07:47:07+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10108"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126828403_1650041235",
      "id": "paragraph_1604126828403_1650041235",
      "dateCreated": "2020-10-31T07:47:08+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10109"
    },
    {
      "text": "%md\nДля нас же удобнее пользоваться несколько другим способом обращения к базе и чтения сразу в структуру DataFrame.\n\n```python\nimport pandas as pd\nwith engine.connect() as session:\n    sql=\"SELECT * FROM sng_all_station;\"\n    df=pd.read_sql(sql, con=session)\ndf.sample(5)\n```\n\nЧасто надо запросить только часть данных. В этом случае в запрос мы добавим паарметр LIMIT и запрос будет выглядеть так \n```sql\nSELECT * FROM sng_all_station LIMIT 10\n```\n\n(выведет только первые 10 строк).\n\nЕсли мы хотим запросить только некотрые столбцы, то надо перечислить их вместо `*`. Например, \n\n```sql\nSELECT `Наименование`, `Код станции` FROM sng_all_station LIMIT 10\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Для нас же удобнее пользоваться несколько другим способом обращения к базе и чтения сразу в структуру DataFrame.</p>\n<pre><code class=\"language-python\">import pandas as pd\nwith engine.connect() as session:\n    sql=&quot;SELECT * FROM sng_all_station;&quot;\n    df=pd.read_sql(sql, con=session)\ndf.sample(5)\n</code></pre>\n<p>Часто надо запросить только часть данных. В этом случае в запрос мы добавим паарметр LIMIT и запрос будет выглядеть так</p>\n<pre><code class=\"language-sql\">SELECT * FROM sng_all_station LIMIT 10\n</code></pre>\n<p>(выведет только первые 10 строк).</p>\n<p>Если мы хотим запросить только некотрые столбцы, то надо перечислить их вместо <code>*</code>. Например,</p>\n<pre><code class=\"language-sql\">SELECT `Наименование`, `Код станции` FROM sng_all_station LIMIT 10\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126828795_1279345073",
      "id": "paragraph_1604126828795_1279345073",
      "dateCreated": "2020-10-31T07:47:08+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10110"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126828974_784987166",
      "id": "paragraph_1604126828974_784987166",
      "dateCreated": "2020-10-31T07:47:08+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10111"
    },
    {
      "text": "%md\nПолный синтаксис оператора SELECT:\n\n```sql\nSELECT column_list \nFROM table_name \n[WHERE условие] \n[GROUP BY условие] \n[HAVING условие] \n[ORDER BY условие] \n```\n\nПараметр `WHERE` позволяет задавать условия выбора данных.\n\n```sql\nSELECT `Наименование`, `Код станции` FROM sng_all_station WHERE `Код железной дороги`=7 AND `Код коммерческих операций`>8\n```\n\nКроме этих операций сравнения могут использоваться: «=» (равно), «>» (больше), «>=» (больше или равно), «<=» (меньше или равно) и «<>» (не равно). И логические операторы AND, OR, NOT.",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Полный синтаксис оператора SELECT:</p>\n<pre><code class=\"language-sql\">SELECT column_list \nFROM table_name \n[WHERE условие] \n[GROUP BY условие] \n[HAVING условие] \n[ORDER BY условие] \n</code></pre>\n<p>Параметр <code>WHERE</code> позволяет задавать условия выбора данных.</p>\n<pre><code class=\"language-sql\">SELECT `Наименование`, `Код станции` FROM sng_all_station WHERE `Код железной дороги`=7 AND `Код коммерческих операций`&gt;8\n</code></pre>\n<p>Кроме этих операций сравнения могут использоваться: «=» (равно), «&gt;» (больше), «&gt;=» (больше или равно), «&lt;=» (меньше или равно) и «&lt;&gt;» (не равно). И логические операторы AND, OR, NOT.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126876934_2036714042",
      "id": "paragraph_1604126876934_2036714042",
      "dateCreated": "2020-10-31T07:47:56+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10112"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877125_290307009",
      "id": "paragraph_1604126877125_290307009",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10113"
    },
    {
      "text": "%md\nНа стороне сервера чаще проще и быстрее выполнять групировку данных. Для этого используем параметр `GROUP BY`.\n\n```sql\nSELECT COUNT(`Наименование`) FROM sng_all_station GROUP BY `Код железной дороги`;\n```\n\nМы использовали функцию `COUNT()` (возвращает количество). Есть еще несколько функций, которые могут быть нам полезны:\n- `MAX()` максимальное значение\n- `MIN()` минимальное значение\n- `SUM()` сумма\n- `AVG()` среднее\n\nОператор `HAVING` работает с результатами оператора `GROUP BY`.\n\n```sql\nSELECT COUNT(`Наименование`) AS cnt FROM sng_all_station GROUP BY `Код железной дороги` HAVING cnt>500;\n```\n\nОператор `AS` указывает на псевдоним столбца, который мы хотим использовать. ",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>На стороне сервера чаще проще и быстрее выполнять групировку данных. Для этого используем параметр <code>GROUP BY</code>.</p>\n<pre><code class=\"language-sql\">SELECT COUNT(`Наименование`) FROM sng_all_station GROUP BY `Код железной дороги`;\n</code></pre>\n<p>Мы использовали функцию <code>COUNT()</code> (возвращает количество). Есть еще несколько функций, которые могут быть нам полезны:</p>\n<ul>\n<li><code>MAX()</code> максимальное значение</li>\n<li><code>MIN()</code> минимальное значение</li>\n<li><code>SUM()</code> сумма</li>\n<li><code>AVG()</code> среднее</li>\n</ul>\n<p>Оператор <code>HAVING</code> работает с результатами оператора <code>GROUP BY</code>.</p>\n<pre><code class=\"language-sql\">SELECT COUNT(`Наименование`) AS cnt FROM sng_all_station GROUP BY `Код железной дороги` HAVING cnt&gt;500;\n</code></pre>\n<p>Оператор <code>AS</code> указывает на псевдоним столбца, который мы хотим использовать.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877297_1478864727",
      "id": "paragraph_1604126877297_1478864727",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10114"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877452_751036665",
      "id": "paragraph_1604126877452_751036665",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10115"
    },
    {
      "text": "%md\nЕсли мы хотим получить только уникальные значения, то надо использовать ключевое слово `DISTINCT`.\n\n```sql\nSELECT DISTINCT `Код железной дороги`, `Код коммерческих операций` FROM sng_all_station;\n```\n\nЕсли мы хотим получить отсортированный набор данныз, то надо использовать ключевое слово `ORDER BY`.\n\n```sql\nSELECT * FROM sng_all_station ORDER BY `Код железной дороги` DESC;\n```\n\nКлючевое слово `DESC` указывает сортировать по убыванию. А ключевое слово `ASC` указывает сортировать по возрастания.\n\n```sql\nSELECT * FROM sng_all_station ORDER BY `Код железной дороги` ASC;\n```\n\nЕсли мы хотим получить, например, только 10 последних строк сортировки, можем использовать:\n\n```sql\nSELECT * FROM sng_all_station ORDER BY `Код железной дороги` ASC LIMIT 10;\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true
        },
        "editorMode": "ace/mode/python",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Если мы хотим получить только уникальные значения, то надо использовать ключевое слово <code>DISTINCT</code>.</p>\n<pre><code class=\"language-sql\">SELECT DISTINCT `Код железной дороги`, `Код коммерческих операций` FROM sng_all_station;\n</code></pre>\n<p>Если мы хотим получить отсортированный набор данныз, то надо использовать ключевое слово <code>ORDER BY</code>.</p>\n<pre><code class=\"language-sql\">SELECT * FROM sng_all_station ORDER BY `Код железной дороги` DESC;\n</code></pre>\n<p>Ключевое слово <code>DESC</code> указывает сортировать по убыванию. А ключевое слово <code>ASC</code> указывает сортировать по возрастания.</p>\n<pre><code class=\"language-sql\">SELECT * FROM sng_all_station ORDER BY `Код железной дороги` ASC;\n</code></pre>\n<p>Если мы хотим получить, например, только 10 последних строк сортировки, можем использовать:</p>\n<pre><code class=\"language-sql\">SELECT * FROM sng_all_station ORDER BY `Код железной дороги` ASC LIMIT 10;\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877640_1357244780",
      "id": "paragraph_1604126877640_1357244780",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10116"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877779_1301496817",
      "id": "paragraph_1604126877779_1301496817",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10117"
    },
    {
      "text": "%md\nSQL запросом можно объединять несколько таблиц. Для этого используем оператор JOIN.\n\n- `(INNER) JOIN`: Возвращает записи, имеющие совпадающие значения в обеих таблицах\n- `LEFT JOIN`: Возвращает все записи из левой таблицы и совпадающие записи из правой таблицы\n- `RIGHT JOIN`: Возвращает все записи из правой таблицы и совпадающие записи из левой таблицы\n- `FULL JOIN`: Возвращает все записи при наличии совпадения в левой или правой таблице.\\\n\nУ нас есть таблица с названиями дорог.\n\n```python\nimport pandas as pd\nwith engine.connect() as session:\n    sql=\"SELECT * FROM sng_name_road;\"\n    df=pd.read_sql(sql, con=session)\ndf.sample(5)\n```\n\nПример такого запроса, который объединит таблицы.\n\n```sql\nSELECT `Наименование`, `Код станции`, `Наименование железной дороги` FROM sng_all_station t1 JOIN sng_name_road t2 ON t1.`Код железной дороги`=t2.`Код железной дороги`;\n```\n\nЗапрос можно усложнить.\n\n```sql\nSELECT `Наименование` AS `Наим`, `Код станции` AS `КОД`, t2.`Наименование железной дороги` FROM sng_all_station t1 JOIN sng_name_road t2 ON t1.`Код железной дороги`=t2.`Код железной дороги`;\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>SQL запросом можно объединять несколько таблиц. Для этого используем оператор JOIN.</p>\n<ul>\n<li><code>(INNER) JOIN</code>: Возвращает записи, имеющие совпадающие значения в обеих таблицах</li>\n<li><code>LEFT JOIN</code>: Возвращает все записи из левой таблицы и совпадающие записи из правой таблицы</li>\n<li><code>RIGHT JOIN</code>: Возвращает все записи из правой таблицы и совпадающие записи из левой таблицы</li>\n<li><code>FULL JOIN</code>: Возвращает все записи при наличии совпадения в левой или правой таблице.\\</li>\n</ul>\n<p>У нас есть таблица с названиями дорог.</p>\n<pre><code class=\"language-python\">import pandas as pd\nwith engine.connect() as session:\n    sql=&quot;SELECT * FROM sng_name_road;&quot;\n    df=pd.read_sql(sql, con=session)\ndf.sample(5)\n</code></pre>\n<p>Пример такого запроса, который объединит таблицы.</p>\n<pre><code class=\"language-sql\">SELECT `Наименование`, `Код станции`, `Наименование железной дороги` FROM sng_all_station t1 JOIN sng_name_road t2 ON t1.`Код железной дороги`=t2.`Код железной дороги`;\n</code></pre>\n<p>Запрос можно усложнить.</p>\n<pre><code class=\"language-sql\">SELECT `Наименование` AS `Наим`, `Код станции` AS `КОД`, t2.`Наименование железной дороги` FROM sng_all_station t1 JOIN sng_name_road t2 ON t1.`Код железной дороги`=t2.`Код железной дороги`;\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126878108_562821266",
      "id": "paragraph_1604126878108_562821266",
      "dateCreated": "2020-10-31T07:47:58+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10118"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604126877958_221619679",
      "id": "paragraph_1604126877958_221619679",
      "dateCreated": "2020-10-31T07:47:57+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10119"
    },
    {
      "text": "%md\n# Задание\n\n1. Сгруппируйте и посчитайте количество кодов коммерческих операций в таблице `sng_all_station`\n2. Сделайте выборку станнций с кодом коммерческих операций больше 100\n3. Объедините таблицы `sng_all_station` и `sng_commercial` по полю `Код коммерческих операций`\n4. Измените запрос последней операции так, чтобы он выводил только 10 строк таблицы с самыми большими кодами операций",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:22+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Задание</h1>\n<ol>\n<li>Сгруппируйте и посчитайте количество кодов коммерческих операций в таблице <code>sng_all_station</code></li>\n<li>Сделайте выборку станнций с кодом коммерческих операций больше 100</li>\n<li>Объедините таблицы <code>sng_all_station</code> и <code>sng_commercial</code> по полю <code>Код коммерческих операций</code></li>\n<li>Измените запрос последней операции так, чтобы он выводил только 10 строк таблицы с самыми большими кодами операций</li>\n</ol>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127107993_1362093020",
      "id": "paragraph_1604127107993_1362093020",
      "dateCreated": "2020-10-31T07:51:47+0100",
      "dateStarted": "2020-11-01T19:37:22+0100",
      "dateFinished": "2020-11-01T19:37:22+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10120"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:23+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127108854_870432350",
      "id": "paragraph_1604127108854_870432350",
      "dateCreated": "2020-10-31T07:51:48+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10121"
    },
    {
      "text": "%md\n# Интерактивные формы\n\nВ Apache Zeppelin есть возможность использовать встроенные формы для ввода и отображения информации. \n\n```python\nimport pandas as pd\nimport random #библиотека отвечает за генерацию случайных чисел\n\n#создадим DataFrame, используем генератор двумерного списка 3 на 12\na=pd.DataFrame([[random.randint(1,100) for x in range(3)] for x in range(12)], \n                index=[str(x) for x in range(1,13)], columns=['a','b', 'c'])\n\n#добавим столбец 'M'\na['M']=[x for x in range(1,13)]\n\n#отобразим данные\nz.show(a)\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:37:23+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Интерактивные формы</h1>\n<p>В Apache Zeppelin есть возможность использовать встроенные формы для ввода и отображения информации.</p>\n<pre><code class=\"language-python\">import pandas as pd\nimport random #библиотека отвечает за генерацию случайных чисел\n\n#создадим DataFrame, используем генератор двумерного списка 3 на 12\na=pd.DataFrame([[random.randint(1,100) for x in range(3)] for x in range(12)], \n                index=[str(x) for x in range(1,13)], columns=['a','b', 'c'])\n\n#добавим столбец 'M'\na['M']=[x for x in range(1,13)]\n\n#отобразим данные\nz.show(a)\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1603998704834_1624185478",
      "id": "paragraph_1603998704834_1624185478",
      "dateCreated": "2020-10-29T20:11:44+0100",
      "dateStarted": "2020-11-01T19:37:23+0100",
      "dateFinished": "2020-11-01T19:37:23+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10122"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:39:14+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {
                    "columns": [
                      {
                        "name": "a0",
                        "visible": true,
                        "width": "*",
                        "sort": {},
                        "filters": [
                          {
                            "term": ""
                          }
                        ],
                        "pinned": ""
                      },
                      {
                        "name": "b1",
                        "visible": true,
                        "width": "*",
                        "sort": {},
                        "filters": [
                          {}
                        ],
                        "pinned": ""
                      },
                      {
                        "name": "c2",
                        "visible": true,
                        "width": "*",
                        "sort": {},
                        "filters": [
                          {}
                        ],
                        "pinned": ""
                      },
                      {
                        "name": "M3",
                        "visible": true,
                        "width": "*",
                        "sort": {},
                        "filters": [
                          {}
                        ],
                        "pinned": ""
                      }
                    ],
                    "scrollFocus": {},
                    "selection": [],
                    "grouping": {
                      "grouping": [],
                      "aggregations": [],
                      "rowExpandedStates": {}
                    },
                    "treeView": {},
                    "pagination": {
                      "paginationCurrentPage": 1,
                      "paginationPageSize": 250
                    }
                  },
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "a": "string",
                      "b": "string",
                      "c": "string",
                      "M": "string"
                    }
                  },
                  "updated": false,
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  }
                },
                "multiBarChart": {
                  "rotate": {
                    "degree": "-45"
                  },
                  "xLabelStatus": "default"
                },
                "stackedAreaChart": {
                  "rotate": {
                    "degree": "-45"
                  },
                  "xLabelStatus": "default"
                },
                "lineChart": {
                  "rotate": {
                    "degree": "-45"
                  },
                  "xLabelStatus": "default",
                  "isDateFormat": false,
                  "forceY": true
                },
                "scatterChart": {
                  "yAxis": {
                    "name": "b",
                    "index": 1,
                    "aggr": "sum"
                  },
                  "xAxis": {
                    "name": "M",
                    "index": 3,
                    "aggr": "sum"
                  },
                  "size": {
                    "name": "b",
                    "index": 1,
                    "aggr": "sum"
                  }
                },
                "pieChart": {}
              },
              "keys": [
                {
                  "name": "M",
                  "index": 3,
                  "aggr": "sum"
                }
              ],
              "groups": [],
              "values": [
                {
                  "name": "c",
                  "index": 2,
                  "aggr": "sum"
                },
                {
                  "name": "a",
                  "index": 0,
                  "aggr": "sum"
                }
              ],
              "commonSetting": {}
            },
            "helium": {}
          }
        },
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604000163634_615992821",
      "id": "paragraph_1604000163634_615992821",
      "dateCreated": "2020-10-29T20:36:03+0100",
      "dateStarted": "2020-11-01T19:37:23+0100",
      "dateFinished": "2020-11-01T19:38:47+0100",
      "status": "ABORT",
      "$$hashKey": "object:10123",
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "org.apache.zeppelin.interpreter.InterpreterException: Fail to interpret python code\n\tat org.apache.zeppelin.jupyter.JupyterKernelInterpreter.internalInterpret(JupyterKernelInterpreter.java:270)\n\tat org.apache.zeppelin.interpreter.AbstractInterpreter.interpret(AbstractInterpreter.java:47)\n\tat org.apache.zeppelin.interpreter.LazyOpenInterpreter.interpret(LazyOpenInterpreter.java:110)\n\tat org.apache.zeppelin.interpreter.remote.RemoteInterpreterServer$InterpretJob.jobRun(RemoteInterpreterServer.java:776)\n\tat org.apache.zeppelin.interpreter.remote.RemoteInterpreterServer$InterpretJob.jobRun(RemoteInterpreterServer.java:668)\n\tat org.apache.zeppelin.scheduler.Job.run(Job.java:172)\n\tat org.apache.zeppelin.scheduler.AbstractScheduler.runJob(AbstractScheduler.java:130)\n\tat org.apache.zeppelin.scheduler.FIFOScheduler.lambda$runJobInScheduler$0(FIFOScheduler.java:39)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\nCaused by: java.lang.NullPointerException\n\tat org.apache.zeppelin.jupyter.JupyterKernelInterpreter.internalInterpret(JupyterKernelInterpreter.java:254)\n\t... 10 more\n"
          }
        ]
      }
    },
    {
      "text": "%md\nСредствами Apache Zeppelin также можно создавать интерактивные формы и запрешивать данные. Например, будем запрашивать параметр для фильтра.\n\n```python\nimport pandas as pd\n\n# Создадим датафрейм\ndf=pd.DataFrame([['Виктор', 'Петров', '1'],['Максим','Федоров',  '2'],['Марина', 'Кошечкина','2']], columns=['Имя', 'Фамилия', 'Отдел'])\n\n#оператор, создает окно запроса\nname=z.input('Введите имя', 'Максим')\ndf[df['Имя']==name]\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:43+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Средствами Apache Zeppelin также можно создавать интерактивные формы и запрешивать данные. Например, будем запрашивать параметр для фильтра.</p>\n<pre><code class=\"language-python\">import pandas as pd\n\n# Создадим датафрейм\ndf=pd.DataFrame([['Виктор', 'Петров', '1'],['Максим','Федоров',  '2'],['Марина', 'Кошечкина','2']], columns=['Имя', 'Фамилия', 'Отдел'])\n\n#оператор, создает окно запроса\nname=z.input('Введите имя', 'Максим')\ndf[df['Имя']==name]\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127705406_1458318382",
      "id": "paragraph_1604127705406_1458318382",
      "dateCreated": "2020-10-31T08:01:45+0100",
      "dateStarted": "2020-11-01T19:38:43+0100",
      "dateFinished": "2020-11-01T19:38:43+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10124"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:43+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127950219_1626216534",
      "id": "paragraph_1604127950219_1626216534",
      "dateCreated": "2020-10-31T08:05:50+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10125"
    },
    {
      "text": "%md\nЕсть вараинт запрашивать данные в виде выпадающего списка. \n\n```python\np=z.select(\"Выберите отдел\", [(\"1\", \"Отдел 1\"),\n                      (\"2\", \"Отдел 2\")], \"1\")\ndf[df['Отдел']==p]\n```\n\n`[(\"1\", \"Отдел 1\")]` первый параметр - значение, которое вернет оператор. Второй - отображаемое значение.",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Есть вараинт запрашивать данные в виде выпадающего списка.</p>\n<pre><code class=\"language-python\">p=z.select(&quot;Выберите отдел&quot;, [(&quot;1&quot;, &quot;Отдел 1&quot;),\n                      (&quot;2&quot;, &quot;Отдел 2&quot;)], &quot;1&quot;)\ndf[df['Отдел']==p]\n</code></pre>\n<p><code>[(&quot;1&quot;, &quot;Отдел 1&quot;)]</code> первый параметр - значение, которое вернет оператор. Второй - отображаемое значение.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127953915_1387994925",
      "id": "paragraph_1604127953915_1387994925",
      "dateCreated": "2020-10-31T08:05:53+0100",
      "dateStarted": "2020-11-01T19:38:47+0100",
      "dateFinished": "2020-11-01T19:38:47+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10126"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127954264_859264167",
      "id": "paragraph_1604127954264_859264167",
      "dateCreated": "2020-10-31T08:05:54+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10127"
    },
    {
      "text": "%md\nТоже самое, но с использованием чек-боксов.\n\n```python\n\np=z.checkbox(\"Выберите отдел\",  [(\"1\", \"Отдел 1\"),\n                      (\"2\", \"Отдел 2\")], \"1\")\ndf[df['Отдел'].isin(p)]\n```",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Тоже самое, но с использованием чек-боксов.</p>\n<pre><code class=\"language-python\">\np=z.checkbox(&quot;Выберите отдел&quot;,  [(&quot;1&quot;, &quot;Отдел 1&quot;),\n                      (&quot;2&quot;, &quot;Отдел 2&quot;)], &quot;1&quot;)\ndf[df['Отдел'].isin(p)]\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127954441_534984791",
      "id": "paragraph_1604127954441_534984791",
      "dateCreated": "2020-10-31T08:05:54+0100",
      "dateStarted": "2020-11-01T19:38:47+0100",
      "dateFinished": "2020-11-01T19:38:47+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10128"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604127954629_122088774",
      "id": "paragraph_1604127954629_122088774",
      "dateCreated": "2020-10-31T08:05:54+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10129"
    },
    {
      "text": "%md\nДавайте усложним пример и сделаем его более функциональным.\n\nДля выпадающего списка.\n\n```python\ns=[] #созданим пустой список\n\nfor i in df['Отдел'].unique(): #наполним список уникальными значениями из столбца таблицы\n    s.append((i,\"Отдел\"+i)) # параметр, отображаемое значение\n    \np=z.select(\"Выберите отдел\",s, \"1\")\ndf[df['Отдел']==p]\n```\n\nДля чек-бокса.\n\n```python\ns=[]\nfor i in df['Отдел'].unique():\n    s.append((i,\"Отдел\"+i))\np=z.checkbox(\"Выберите отдел\", s, \"1\")\ndf[df['Отдел'].isin(p)] #отобразит только строки где имеется значение из списка р\n```\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Давайте усложним пример и сделаем его более функциональным.</p>\n<p>Для выпадающего списка.</p>\n<pre><code class=\"language-python\">s=[] #созданим пустой список\n\nfor i in df['Отдел'].unique(): #наполним список уникальными значениями из столбца таблицы\n    s.append((i,&quot;Отдел&quot;+i)) # параметр, отображаемое значение\n    \np=z.select(&quot;Выберите отдел&quot;,s, &quot;1&quot;)\ndf[df['Отдел']==p]\n</code></pre>\n<p>Для чек-бокса.</p>\n<pre><code class=\"language-python\">s=[]\nfor i in df['Отдел'].unique():\n    s.append((i,&quot;Отдел&quot;+i))\np=z.checkbox(&quot;Выберите отдел&quot;, s, &quot;1&quot;)\ndf[df['Отдел'].isin(p)] #отобразит только строки где имеется значение из списка р\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604128166582_2144458725",
      "id": "paragraph_1604128166582_2144458725",
      "dateCreated": "2020-10-31T08:09:26+0100",
      "dateStarted": "2020-11-01T19:38:47+0100",
      "dateFinished": "2020-11-01T19:38:47+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10130"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604128166729_822478437",
      "id": "paragraph_1604128166729_822478437",
      "dateCreated": "2020-10-31T08:09:26+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10131"
    },
    {
      "text": "%md\n# Задание\n\nИспользуйте объединенную таблицу SQL `sng_station`.\n1. Создайте форму `input` для отображения стаций с кодами больше указанного значения.\n2. Создайте формы отдельно с выпадающим списком, отдельно с чек боксом которая позволит фильстровать данные по названию дороги.",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Задание</h1>\n<p>Используйте объединенную таблицу SQL <code>sng_station</code>.</p>\n<ol>\n<li>Создайте форму <code>input</code> для отображения стаций с кодами больше указанного значения.</li>\n<li>Создайте формы отдельно с выпадающим списком, отдельно с чек боксом которая позволит фильстровать данные по названию дороги.</li>\n</ol>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604128166916_1392904052",
      "id": "paragraph_1604128166916_1392904052",
      "dateCreated": "2020-10-31T08:09:26+0100",
      "dateStarted": "2020-11-01T19:38:47+0100",
      "dateFinished": "2020-11-01T19:38:47+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10132"
    },
    {
      "text": "%ipython\n",
      "user": "admin",
      "dateUpdated": "2020-11-01T19:38:47+0100",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionSupport": true,
          "completionKey": "TAB"
        },
        "editorMode": "ace/mode/python"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1604128167080_1012655421",
      "id": "paragraph_1604128167080_1012655421",
      "dateCreated": "2020-10-31T08:09:27+0100",
      "status": "FINISHED",
      "$$hashKey": "object:10133"
    }
  ],
  "name": "BookRZD 02",
  "id": "2FP11E8UH",
  "defaultInterpreterGroup": "python",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false,
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {},
  "path": "/BookRZD 02"
}